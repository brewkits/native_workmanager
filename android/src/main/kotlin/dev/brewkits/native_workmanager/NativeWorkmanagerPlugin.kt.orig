package dev.brewkits.native_workmanager

import android.content.Context
import android.util.Log
import dev.brewkits.native_workmanager.engine.FlutterEngineManager
import dev.brewkits.native_workmanager.domain.TaskChain
import dev.brewkits.native_workmanager.domain.TaskRequest
import io.flutter.embedding.engine.plugins.FlutterPlugin
import io.flutter.plugin.common.EventChannel
import io.flutter.plugin.common.MethodCall
import io.flutter.plugin.common.MethodChannel
import io.flutter.plugin.common.MethodChannel.MethodCallHandler
import io.flutter.plugin.common.MethodChannel.Result
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.cancel
import kotlinx.coroutines.launch

/**
 * Native WorkManager Flutter Plugin for Android.
 *
 * This plugin provides a bridge between Flutter and the KMP WorkManager library,
 * enabling native background task scheduling without Flutter Engine overhead.
 */
class NativeWorkmanagerPlugin : FlutterPlugin, MethodCallHandler {

    private lateinit var methodChannel: MethodChannel
    private lateinit var eventChannel: EventChannel
    private lateinit var progressChannel: EventChannel
    private lateinit var context: Context

    private var eventSink: EventChannel.EventSink? = null
    private var progressSink: EventChannel.EventSink? = null

    private val scope = CoroutineScope(Dispatchers.Main + SupervisorJob())

    private lateinit var scheduler: SimpleWorkManagerScheduler

    companion object {
        private const val TAG = "NativeWorkmanagerPlugin"
        private const val METHOD_CHANNEL = "dev.brewkits/native_workmanager"
        private const val EVENT_CHANNEL = "dev.brewkits/native_workmanager/events"
        private const val PROGRESS_CHANNEL = "dev.brewkits/native_workmanager/progress"
    }

    override fun onAttachedToEngine(binding: FlutterPlugin.FlutterPluginBinding) {
        context = binding.applicationContext

        // Initialize scheduler
        scheduler = SimpleWorkManagerScheduler(context)

        // Setup Method Channel
        methodChannel = MethodChannel(binding.binaryMessenger, METHOD_CHANNEL)
        methodChannel.setMethodCallHandler(this)

        // Setup Event Channel for task completion events
        eventChannel = EventChannel(binding.binaryMessenger, EVENT_CHANNEL)
        eventChannel.setStreamHandler(object : EventChannel.StreamHandler {
            override fun onListen(arguments: Any?, events: EventChannel.EventSink?) {
                eventSink = events
                subscribeToTaskEvents()
            }

            override fun onCancel(arguments: Any?) {
                eventSink = null
            }
        })

        // Setup Progress Channel for task progress updates
        progressChannel = EventChannel(binding.binaryMessenger, PROGRESS_CHANNEL)
        progressChannel.setStreamHandler(object : EventChannel.StreamHandler {
            override fun onListen(arguments: Any?, events: EventChannel.EventSink?) {
                progressSink = events
            }

            override fun onCancel(arguments: Any?) {
                progressSink = null
            }
        })
    }

    private fun subscribeToTaskEvents() {
        // Task events will be handled through WorkManager's own status APIs
        // For now, just log that subscription was requested
        Log.d(TAG, "Task event subscription initialized")
    }

    override fun onMethodCall(call: MethodCall, result: Result) {
        when (call.method) {
            "initialize" -> handleInitialize(call, result)
            "enqueue" -> handleEnqueue(call, result)
            "cancel" -> handleCancel(call, result)
            "cancelAll" -> handleCancelAll(result)
            "getTaskStatus" -> handleGetTaskStatus(call, result)
            "enqueueChain" -> handleEnqueueChain(call, result)
            else -> result.notImplemented()
        }
    }

    private fun handleInitialize(call: MethodCall, result: Result) {
        // Koin is already initialized in onAttachedToEngine

        // Initialize Flutter Engine Manager for Dart workers (optional)
        val callbackHandle = call.argument<Long>("callbackHandle")
        if (callbackHandle != null) {
            FlutterEngineManager.setCallbackHandle(callbackHandle)
            Log.d(TAG, "Dart callback handle registered: $callbackHandle")
        } else {
            Log.d(TAG, "No Dart callback handle provided (native workers only)")
        }

        result.success(null)
    }

    private fun handleEnqueue(call: MethodCall, result: Result) {
        scope.launch {
            try {
                val taskId = call.argument<String>("taskId")
                    ?: throw IllegalArgumentException("taskId is required")
                val triggerMap = call.argument<Map<String, Any>>("trigger")
                    ?: throw IllegalArgumentException("trigger is required")
                val workerClassName = call.argument<String>("workerClassName")
                    ?: throw IllegalArgumentException("workerClassName is required")
                val workerConfig = call.argument<Map<String, Any>>("workerConfig")
                    ?: emptyMap()
                val constraintsMap = call.argument<Map<String, Any>>("constraints")
                val existingPolicyStr = call.argument<String>("existingPolicy") ?: "replace"

                val trigger = mapTrigger(triggerMap)
                val constraints = mapConstraints(constraintsMap)
                val existingPolicy = mapExistingPolicy(existingPolicyStr)

                // Convert worker config to JSON string
                val inputJson = workerConfigToJson(workerConfig)

                val scheduleResult = scheduler.enqueue(
                    id = taskId,
                    trigger = trigger,
                    workerClassName = workerClassName,
                    constraints = constraints,
                    inputJson = inputJson,
                    policy = existingPolicy
                )

                result.success(scheduleResult.name)
            } catch (e: Exception) {
                result.error("ENQUEUE_ERROR", e.message, e.stackTraceToString())
            }
        }
    }

    private fun handleCancel(call: MethodCall, result: Result) {
        val taskId = call.argument<String>("taskId")
            ?: return result.error("INVALID_ARGS", "taskId is required", null)

        scheduler.cancel(taskId)
        result.success(null)
    }

    private fun handleCancelAll(result: Result) {
        scheduler.cancelAll()
        result.success(null)
    }

    private fun handleGetTaskStatus(call: MethodCall, result: Result) {
        // TODO: Implement task status query
        result.success(null)
    }

    private fun handleEnqueueChain(call: MethodCall, result: Result) {
        scope.launch {
            try {
                val chainName = call.argument<String>("name")
                val constraintsMap = call.argument<Map<String, Any>>("constraints")
                val stepsData = call.argument<List<List<Map<String, Any>>>>("steps")
                    ?: throw IllegalArgumentException("steps is required")

                val constraints = mapConstraints(constraintsMap)

                // Build the chain
                val firstStep = stepsData.firstOrNull()
                    ?: throw IllegalArgumentException("Chain must have at least one step")

                val firstTasks = firstStep.map { taskData ->
                    mapTaskRequest(taskData)
                }

                var chain: TaskChain = scheduler.beginWith(firstTasks)

                // Add remaining steps
                stepsData.drop(1).forEach { stepTasks ->
                    val tasks = stepTasks.map { taskData ->
                        mapTaskRequest(taskData)
                    }
                    chain = chain.then(tasks)
                }

                scheduler.enqueueChain(chain)

                result.success("ACCEPTED")
            } catch (e: Exception) {
                result.error("CHAIN_ERROR", e.message, e.stackTraceToString())
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════════════
    // TYPE MAPPERS
    // ═══════════════════════════════════════════════════════════════════════════════

    private fun mapTrigger(map: Map<String, Any>): TaskTrigger {
        return when (val type = map["type"] as? String) {
            "oneTime" -> {
                val delayMs = (map["initialDelayMs"] as? Number)?.toLong() ?: 0L
                TaskTrigger.OneTime(delayMs)
            }
            "periodic" -> {
                val intervalMs = (map["intervalMs"] as? Number)?.toLong()
                    ?: throw IllegalArgumentException("intervalMs is required for periodic trigger")
                val flexMs = (map["flexMs"] as? Number)?.toLong()
                TaskTrigger.Periodic(intervalMs, flexMs)
            }
            "exact" -> {
                val scheduledTimeMs = (map["scheduledTimeMs"] as? Number)?.toLong()
                    ?: throw IllegalArgumentException("scheduledTimeMs is required for exact trigger")
                TaskTrigger.Exact(scheduledTimeMs)
            }
            "windowed" -> {
                val earliestMs = (map["earliestMs"] as? Number)?.toLong()
                    ?: throw IllegalArgumentException("earliestMs is required for windowed trigger")
                val latestMs = (map["latestMs"] as? Number)?.toLong()
                    ?: throw IllegalArgumentException("latestMs is required for windowed trigger")
                TaskTrigger.Windowed(earliestMs, latestMs)
            }
            "contentUri" -> {
                val uriString = map["uriString"] as? String
                    ?: throw IllegalArgumentException("uriString is required for contentUri trigger")
                val triggerForDescendants = map["triggerForDescendants"] as? Boolean ?: false
                TaskTrigger.ContentUri(uriString, triggerForDescendants)
            }
            else -> throw IllegalArgumentException("Unknown trigger type: $type")
        }
    }

    private fun mapConstraints(map: Map<String, Any>?): Constraints {
        if (map == null) return Constraints()

        return Constraints(
            requiresNetwork = map["requiresNetwork"] as? Boolean ?: false,
            requiresUnmeteredNetwork = map["requiresUnmeteredNetwork"] as? Boolean ?: false,
            requiresCharging = map["requiresCharging"] as? Boolean ?: false,
            allowWhileIdle = map["allowWhileIdle"] as? Boolean ?: false,
            isHeavyTask = map["isHeavyTask"] as? Boolean ?: false,
            qos = mapQos(map["qos"] as? String),
            exactAlarmIOSBehavior = mapExactAlarmIOSBehavior(map["exactAlarmIOSBehavior"] as? String),
            backoffPolicy = mapBackoffPolicy(map["backoffPolicy"] as? String),
            backoffDelayMs = (map["backoffDelayMs"] as? Number)?.toLong() ?: 30_000L
        )
    }

    private fun mapExistingPolicy(policy: String): ExistingPolicy {
        return when (policy.lowercase()) {
            "keep" -> ExistingPolicy.KEEP
            "replace" -> ExistingPolicy.REPLACE
            else -> ExistingPolicy.REPLACE
        }
    }

    private fun mapQos(qosString: String?): Qos {
        return when (qosString?.lowercase()) {
            "utility" -> Qos.Utility
            "background" -> Qos.Background
            "userinitiated" -> Qos.UserInitiated
            "userinteractive" -> Qos.UserInteractive
            else -> Qos.Background
        }
    }

    private fun mapExactAlarmIOSBehavior(behaviorString: String?): ExactAlarmIOSBehavior {
        return when (behaviorString?.lowercase()) {
            "shownotification" -> ExactAlarmIOSBehavior.SHOW_NOTIFICATION
            "attemptbackgroundrun" -> ExactAlarmIOSBehavior.ATTEMPT_BACKGROUND_RUN
            "throwerror" -> ExactAlarmIOSBehavior.THROW_ERROR
            else -> ExactAlarmIOSBehavior.SHOW_NOTIFICATION
        }
    }

    private fun mapBackoffPolicy(policyString: String?): BackoffPolicy {
        return when (policyString?.lowercase()) {
            "linear" -> BackoffPolicy.LINEAR
            "exponential" -> BackoffPolicy.EXPONENTIAL
            else -> BackoffPolicy.EXPONENTIAL
        }
    }

    private fun mapTaskRequest(data: Map<String, Any>): TaskRequest {
        val id = data["id"] as? String
            ?: throw IllegalArgumentException("Task id is required")
        val workerClassName = data["workerClassName"] as? String
            ?: throw IllegalArgumentException("workerClassName is required")
        val workerConfig = data["workerConfig"] as? Map<String, Any> ?: emptyMap()
        val constraintsMap = data["constraints"] as? Map<String, Any>

        return TaskRequest(
            id = id,
            workerClassName = workerClassName,
            inputJson = workerConfigToJson(workerConfig),
            constraints = mapConstraints(constraintsMap)
        )
    }

    private fun workerConfigToJson(config: Map<String, Any>): String {
        // Simple JSON conversion
        val sb = StringBuilder("{")
        config.entries.forEachIndexed { index, entry ->
            if (index > 0) sb.append(",")
            sb.append("\"${entry.key}\":")
            when (val value = entry.value) {
                is String -> sb.append("\"$value\"")
                is Number -> sb.append(value)
                is Boolean -> sb.append(value)
                is Map<*, *> -> sb.append(workerConfigToJson(value as Map<String, Any>))
                else -> sb.append("\"$value\"")
            }
        }
        sb.append("}")
        return sb.toString()
    }

    override fun onDetachedFromEngine(binding: FlutterPlugin.FlutterPluginBinding) {
        methodChannel.setMethodCallHandler(null)
        scope.cancel()
    }
}

/**
 * Worker factory that creates workers based on worker class name.
 *
 * This factory provides built-in native workers (HTTP, Upload, Download, Sync)
 * as well as support for Dart callback workers.
 */
class FlutterWorkerFactory(
    private val context: Context
) : AndroidWorkerFactory {

    override fun createWorker(workerClassName: String): AndroidWorker? {
        return when (workerClassName) {
            // Built-in native workers (Mode 1 - Zero Flutter Engine)
            "HttpRequestWorker" -> HttpRequestWorker()
            "HttpUploadWorker" -> HttpUploadWorker()
            "HttpDownloadWorker" -> HttpDownloadWorker()
            "HttpSyncWorker" -> HttpSyncWorker()

            // Dart callback worker (Mode 2 - Requires Flutter Engine)
            // Note: Using stub from kmpworkmanager, real implementation needs Flutter engine
            "DartCallbackWorker" -> DartCallbackWorker()

            // Unknown worker
            else -> {
                android.util.Log.w("FlutterWorkerFactory", "Unknown worker: $workerClassName")
                null
            }
        }
    }
}
