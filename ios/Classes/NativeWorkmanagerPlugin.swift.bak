import Flutter
import UIKit
// KMPWorkManager will be available after pod install
// import KMPWorkManager

/// Native WorkManager Flutter Plugin for iOS.
///
/// This plugin provides native background task scheduling using iOS workers
/// (Mode 1: Native HTTP workers) and Dart workers (Mode 2: FlutterEngine-based).
///
/// **Architecture:**
/// - Mode 1: Native workers (HttpRequest, Upload, Download, Sync) - Zero Flutter overhead
/// - Mode 2: Dart workers (DartCallbackWorker) - Full Flutter plugin access
///
/// **Workers are executed via iOS URLSession and FlutterEngine respectively.**
public class NativeWorkmanagerPlugin: NSObject, FlutterPlugin {

    private var methodChannel: FlutterMethodChannel?
    private var eventChannel: FlutterEventChannel?
    private var progressChannel: FlutterEventChannel?

    private var eventSink: FlutterEventSink?
    private var progressSink: FlutterEventSink?

    private static let methodChannelName = "dev.brewkits/native_workmanager"
    private static let eventChannelName = "dev.brewkits/native_workmanager/events"
    private static let progressChannelName = "dev.brewkits/native_workmanager/progress"

    // Background task execution queue
    private let workerQueue = DispatchQueue(label: "dev.brewkits.native_workmanager.worker",
                                           qos: .utility)

    public static func register(with registrar: FlutterPluginRegistrar) {
        let instance = NativeWorkmanagerPlugin()

        // Setup Method Channel
        let methodChannel = FlutterMethodChannel(
            name: methodChannelName,
            binaryMessenger: registrar.messenger()
        )
        registrar.addMethodCallDelegate(instance, channel: methodChannel)
        instance.methodChannel = methodChannel

        // Setup Event Channel for task completion events
        let eventChannel = FlutterEventChannel(
            name: eventChannelName,
            binaryMessenger: registrar.messenger()
        )
        eventChannel.setStreamHandler(instance)
        instance.eventChannel = eventChannel

        // Setup Progress Channel for task progress updates
        let progressChannel = FlutterEventChannel(
            name: progressChannelName,
            binaryMessenger: registrar.messenger()
        )
        progressChannel.setStreamHandler(ProgressStreamHandler(plugin: instance))
        instance.progressChannel = progressChannel

        // Register BGTaskScheduler handlers (iOS 13+)
        if #available(iOS 13.0, *) {
            // Validate Info.plist configuration
            InfoPlistValidator.printSetupGuideIfNeeded()

            BGTaskSchedulerManager.shared.registerHandlers()
            BGTaskSchedulerManager.shared.onTaskComplete = { taskId, success, message in
                instance.emitTaskEvent(taskId: taskId, success: success, message: message)
            }
        }

        print("NativeWorkmanagerPlugin: Registered")
    }

    public func handle(_ call: FlutterMethodCall, result: @escaping FlutterResult) {
        switch call.method {
        case "initialize":
            handleInitialize(call: call, result: result)
        case "enqueue":
            handleEnqueue(call: call, result: result)
        case "cancel":
            handleCancel(call: call, result: result)
        case "cancelAll":
            handleCancelAll(result: result)
        case "getTaskStatus":
            handleGetTaskStatus(call: call, result: result)
        case "enqueueChain":
            handleEnqueueChain(call: call, result: result)
        default:
            result(FlutterMethodNotImplemented)
        }
    }

    // MARK: - Method Handlers

    private func handleInitialize(call: FlutterMethodCall, result: @escaping FlutterResult) {
        // Initialize KMP WorkManager
        KMPBridge.shared.initialize()

        // Extract callback handle if provided (for Dart workers)
        if let args = call.arguments as? [String: Any],
           let callbackHandle = args["callbackHandle"] as? Int64 {
            FlutterEngineManager.shared.setCallbackHandle(callbackHandle)
            print("NativeWorkManager: Initialized with Dart callback handle: \(callbackHandle)")
        } else {
            print("NativeWorkManager: Initialized (KMP native workers)")
        }

        result(nil)
    }

    private func handleEnqueue(call: FlutterMethodCall, result: @escaping FlutterResult) {
        guard let args = call.arguments as? [String: Any],
              let taskId = args["taskId"] as? String,
              let triggerMap = args["trigger"] as? [String: Any],
              let workerClassName = args["workerClassName"] as? String else {
            result(FlutterError(code: "INVALID_ARGS", message: "Missing required arguments", details: nil))
            return
        }

        print("NativeWorkManager: Enqueue task '\(taskId)' with worker '\(workerClassName)' via KMP scheduler")

        // Get KMP scheduler
        guard let scheduler = KMPBridge.shared.getScheduler() else {
            result(FlutterError(
                code: "NOT_INITIALIZED",
                message: "KMP WorkManager not initialized",
                details: nil
            ))
            return
        }

        // Extract parameters
        let constraintsMap = args["constraints"] as? [String: Any]
        let workerConfig = args["workerConfig"] as? [String: Any]
        let policyString = args["existingPolicy"] as? String

        // Convert workerConfig to JSON string for KMP
        var inputJson: String? = nil
        if let config = workerConfig,
           let jsonData = try? JSONSerialization.data(withJSONObject: config),
           let jsonString = String(data: jsonData, encoding: .utf8) {
            inputJson = jsonString
        }

        // Call KMP scheduler
        KMPSchedulerBridge.enqueue(
            scheduler: scheduler,
            taskId: taskId,
            triggerMap: triggerMap,
            workerClassName: workerClassName,
            constraintsMap: constraintsMap,
            inputJson: inputJson,
            policyString: policyString
        ) { scheduleResult in
            switch scheduleResult {
            case .success(let schedResult):
                let resultString = KMPSchedulerBridge.scheduleResultToString(schedResult)
                print("✅ KMP Scheduler: Task '\(taskId)' enqueued with result: \(resultString)")
                result(resultString)
            case .failure(let error):
                print("❌ KMP Scheduler: Failed to enqueue task '\(taskId)' - \(error)")
                result(FlutterError(
                    code: "ENQUEUE_FAILED",
                    message: error.localizedDescription,
                    details: nil
                ))
            }
        }
    }

    // MARK: - Legacy Implementation (Removed in Phase 2)
    // The old direct Swift worker execution has been replaced with KMP scheduler calls
    // All background tasks are now scheduled through kmpworkmanager v2.1.2

    private func handleEnqueue_Legacy(call: FlutterMethodCall, result: @escaping FlutterResult) {
        // This method is kept for reference only
        // See git history for original implementation
        result(FlutterError(code: "DEPRECATED", message: "Legacy method removed", details: nil))

        // Parse constraints
        let constraintsMap = args["constraints"] as? [String: Any]
        let requiresNetwork = constraintsMap?["requiresNetwork"] as? Bool ?? false
        let requiresCharging = constraintsMap?["requiresCharging"] as? Bool ?? false
        let isHeavyTask = constraintsMap?["isHeavyTask"] as? Bool ?? false
        let qos = constraintsMap?["qos"] as? String ?? "background"
        let exactAlarmIOSBehavior = constraintsMap?["exactAlarmIOSBehavior"] as? String ?? "showNotification"

        // Parse trigger
        let triggerType = triggerMap["type"] as? String ?? "oneTime"

        switch triggerType {
        case "oneTime":
            // One-time task with optional delay
            let delayMs = (triggerMap["initialDelayMs"] as? NSNumber)?.int64Value ?? 0
            let delaySeconds = TimeInterval(delayMs) / 1000.0

            if delaySeconds > 0 {
                // Delayed execution
                workerQueue.asyncAfter(deadline: .now() + delaySeconds) { [weak self] in
                    self?.executeWorker(
                        taskId: taskId,
                        workerClassName: workerClassName,
                        workerConfig: workerConfig,
                        qos: qos
                    )
                }
            } else {
                // Immediate execution
                workerQueue.async { [weak self] in
                    self?.executeWorker(
                        taskId: taskId,
                        workerClassName: workerClassName,
                        workerConfig: workerConfig,
                        qos: qos
                    )
                }
            }

        case "exact":
            // Execute at exact timestamp - Handle iOS limitation
            guard let scheduledTimeMs = (triggerMap["scheduledTimeMs"] as? NSNumber)?.int64Value else {
                result(FlutterError(code: "INVALID_TRIGGER",
                                   message: "scheduledTimeMs is required for exact trigger",
                                   details: nil))
                return
            }

            let scheduledDate = Date(timeIntervalSince1970: TimeInterval(scheduledTimeMs) / 1000.0)

            // Handle iOS exact alarm behavior
            switch exactAlarmIOSBehavior {
            case "throwError":
                // Fail fast - force developer awareness
                result(FlutterError(
                    code: "UNSUPPORTED_IOS",
                    message: "iOS does not support exact alarms for code execution. Use SHOW_NOTIFICATION or ATTEMPT_BACKGROUND_RUN instead.",
                    details: nil
                ))
                return

            case "showNotification":
                // Show UNNotification (guaranteed, safe)
                print("NativeWorkManager: Scheduling notification for exact time (iOS limitation)")
                // TODO: Schedule UNNotification
                // For now, log warning and attempt background run
                print("⚠️ iOS does not support exact code execution. Notification scheduling not yet implemented. Attempting background run instead.")
                fallthrough

            case "attemptBackgroundRun":
                // Attempt background execution (unreliable)
                if #available(iOS 13.0, *) {
                    print("NativeWorkManager: Attempting background run at exact time (NOT GUARANTEED)")
                    let success = BGTaskSchedulerManager.shared.scheduleTask(
                        taskId: taskId,
                        workerClassName: workerClassName,
                        workerConfig: workerConfig,
                        earliestBeginDate: scheduledDate,
                        requiresNetwork: requiresNetwork,
                        requiresExternalPower: requiresCharging,
                        isHeavyTask: isHeavyTask,
                        qos: qos
                    )

                    if !success {
                        result(FlutterError(code: "SCHEDULE_FAILED",
                                           message: "Failed to schedule background task",
                                           details: nil))
                        return
                    }
                } else {
                    // iOS 12 and below: Execute at scheduled time (not guaranteed if app terminated)
                    let delay = max(0, scheduledDate.timeIntervalSinceNow)
                    workerQueue.asyncAfter(deadline: .now() + delay) { [weak self] in
                        self?.executeWorker(
                            taskId: taskId,
                            workerClassName: workerClassName,
                            workerConfig: workerConfig,
                            qos: qos
                        )
                    }
                }

            default:
                // Unknown behavior, use showNotification as fallback
                print("⚠️ Unknown exactAlarmIOSBehavior: \(exactAlarmIOSBehavior). Using showNotification fallback.")
                // Fall through to attempt background run
                let delay = max(0, scheduledDate.timeIntervalSinceNow)
                workerQueue.asyncAfter(deadline: .now() + delay) { [weak self] in
                    self?.executeWorker(
                        taskId: taskId,
                        workerClassName: workerClassName,
                        workerConfig: workerConfig,
                        qos: qos
                    )
                }
            }

        case "windowed":
            // Execute within time window (use earliest time)
            guard let earliestMs = (triggerMap["earliestMs"] as? NSNumber)?.int64Value,
                  let latestMs = (triggerMap["latestMs"] as? NSNumber)?.int64Value else {
                result(FlutterError(code: "INVALID_TRIGGER",
                                   message: "earliestMs and latestMs are required for windowed trigger",
                                   details: nil))
                return
            }

            let earliestDate = Date(timeIntervalSince1970: TimeInterval(earliestMs) / 1000.0)
            let delay = max(0, earliestDate.timeIntervalSinceNow)

            workerQueue.asyncAfter(deadline: .now() + delay) { [weak self] in
                self?.executeWorker(
                    taskId: taskId,
                    workerClassName: workerClassName,
                    workerConfig: workerConfig,
                    qos: qos
                )
            }

        case "periodic":
            // Periodic task: Use BGTaskScheduler (iOS 13+)
            if #available(iOS 13.0, *) {
                let success = BGTaskSchedulerManager.shared.scheduleTask(
                    taskId: taskId,
                    workerClassName: workerClassName,
                    workerConfig: workerConfig,
                    requiresNetwork: requiresNetwork,
                    requiresExternalPower: requiresCharging,
                    isHeavyTask: isHeavyTask,
                    qos: qos
                )

                if !success {
                    result(FlutterError(code: "SCHEDULE_FAILED",
                                       message: "Failed to schedule background task",
                                       details: nil))
                    return
                }
            } else {
                // iOS 12 and below: Execute immediately (can't do periodic)
                workerQueue.async { [weak self] in
                    self?.executeWorker(
                        taskId: taskId,
                        workerClassName: workerClassName,
                        workerConfig: workerConfig,
                        qos: qos
                    )
                }
            }

        case "contentUri":
            // ContentUri trigger is Android-only
            result(FlutterError(
                code: "UNSUPPORTED_IOS",
                message: "ContentUri trigger is Android-only. iOS does not support content provider observation.",
                details: nil
            ))
            return

        default:
            result(FlutterError(code: "INVALID_TRIGGER",
                               message: "Unknown trigger type: \(triggerType)",
                               details: nil))
            return
        }

        result("ACCEPTED")
    }

    /// Execute a worker task with specified QoS.
    private func executeWorker(
        taskId: String,
        workerClassName: String,
        workerConfig: [String: Any],
        qos: String = "background"
    ) {
        // Map QoS string to DispatchQoS
        let qosClass = mapQoS(qos)

        Task {
            await withCheckedContinuation { (continuation: CheckedContinuation<Void, Never>) in
                DispatchQueue.global(qos: qosClass).async {
                    Task {
                        print("NativeWorkManager: Executing task '\(taskId)' with QoS: \(qos)...")

                        // Convert worker config to JSON string
                        let inputJson: String?
                        do {
                            let jsonData = try JSONSerialization.data(withJSONObject: workerConfig)
                            inputJson = String(data: jsonData, encoding: .utf8)
                        } catch {
                            print("NativeWorkManager: Error serializing worker config: \(error)")
                            self.emitTaskEvent(taskId: taskId, success: false, message: "Config serialization failed")
                            continuation.resume()
                            return
                        }

                        // Create worker
                        guard let worker = IosWorkerFactory.createWorker(className: workerClassName) else {
                            print("NativeWorkManager: Unknown worker class: \(workerClassName)")
                            self.emitTaskEvent(taskId: taskId, success: false, message: "Unknown worker class")
                            continuation.resume()
                            return
                        }

                        // Execute worker
                        do {
                            let success = try await worker.doWork(input: inputJson)

                            if success {
                                print("NativeWorkManager: Task '\(taskId)' completed successfully")
                                self.emitTaskEvent(taskId: taskId, success: true, message: nil)
                            } else {
                                print("NativeWorkManager: Task '\(taskId)' failed")
                                self.emitTaskEvent(taskId: taskId, success: false, message: "Worker returned false")
                            }
                        } catch {
                            print("NativeWorkManager: Task '\(taskId)' error: \(error.localizedDescription)")
                            self.emitTaskEvent(taskId: taskId, success: false, message: error.localizedDescription)
                        }

                        continuation.resume()
                    }
                }
            }
        }
    }

    /// Map QoS string to DispatchQoS.QoSClass
    private func mapQoS(_ qosString: String) -> DispatchQoS.QoSClass {
        switch qosString.lowercased() {
        case "utility":
            return .utility
        case "background":
            return .background
        case "userinitiated":
            return .userInitiated
        case "userinteractive":
            return .userInteractive
        default:
            return .background
        }
    }

    private func handleCancel(call: FlutterMethodCall, result: @escaping FlutterResult) {
        guard let args = call.arguments as? [String: Any],
              let taskId = args["taskId"] as? String else {
            result(FlutterError(code: "INVALID_ARGS", message: "taskId is required", details: nil))
            return
        }

        print("NativeWorkManager: Cancel task \(taskId) via KMP scheduler")

        // Get KMP scheduler
        guard let scheduler = KMPBridge.shared.getScheduler() else {
            // Fallback to legacy BGTaskScheduler if KMP not ready
            if #available(iOS 13.0, *) {
                BGTaskSchedulerManager.shared.cancelTask(taskId: taskId)
            }
            result(nil)
            return
        }

        // Cancel via KMP scheduler
        scheduler.cancel(id: taskId)
        print("✅ KMP Scheduler: Task '\(taskId)' cancelled")
        result(nil)
    }

    private func handleCancelAll(result: @escaping FlutterResult) {
        print("NativeWorkManager: Cancel all tasks via KMP scheduler")

        // Get KMP scheduler
        guard let scheduler = KMPBridge.shared.getScheduler() else {
            // Fallback to legacy BGTaskScheduler if KMP not ready
            if #available(iOS 13.0, *) {
                BGTaskSchedulerManager.shared.cancelAllTasks()
            }
            result(nil)
            return
        }

        // Cancel all via KMP scheduler
        scheduler.cancelAll()
        print("✅ KMP Scheduler: All tasks cancelled")
        result(nil)
    }

    private func handleGetTaskStatus(call: FlutterMethodCall, result: @escaping FlutterResult) {
        // TODO: Implement task status query
        result(nil)
    }

    private func handleEnqueueChain(call: FlutterMethodCall, result: @escaping FlutterResult) {
        guard let args = call.arguments as? [String: Any],
              let stepsData = args["steps"] as? [[Any]] else {
            result(FlutterError(code: "INVALID_ARGS", message: "steps is required", details: nil))
            return
        }

        let chainName = args["name"] as? String
        let constraintsMap = args["constraints"] as? [String: Any]
        let qos = constraintsMap?["qos"] as? String ?? "background"

        print("NativeWorkManager: Enqueue chain '\(chainName ?? "unnamed")' with \(stepsData.count) steps")

        // Execute chain steps sequentially
        workerQueue.async { [weak self] in
            self?.executeChain(
                steps: stepsData,
                chainName: chainName,
                constraintsMap: constraintsMap,
                qos: qos,
                result: result
            )
        }
    }

    /// Execute a task chain sequentially.
    private func executeChain(
        steps: [[Any]],
        chainName: String?,
        constraintsMap: [String: Any]?,
        qos: String,
        result: @escaping FlutterResult
    ) {
        Task {
            for (stepIndex, stepData) in steps.enumerated() {
                print("NativeWorkManager: Chain '\(chainName ?? "unnamed")' - Step \(stepIndex + 1)/\(steps.count)")

                // Parse tasks in this step
                guard let stepTasks = stepData as? [[String: Any]] else {
                    result(FlutterError(
                        code: "INVALID_STEP",
                        message: "Step \(stepIndex) has invalid format",
                        details: nil
                    ))
                    return
                }

                // Execute tasks in parallel (if multiple tasks in step)
                await withTaskGroup(of: Bool.self) { group in
                    for taskData in stepTasks {
                        guard let taskId = taskData["id"] as? String,
                              let workerClassName = taskData["workerClassName"] as? String,
                              let workerConfig = taskData["workerConfig"] as? [String: Any] else {
                            continue
                        }

                        group.addTask {
                            await self.executeWorkerSync(
                                taskId: taskId,
                                workerClassName: workerClassName,
                                workerConfig: workerConfig,
                                qos: qos
                            )
                        }
                    }

                    // Wait for all tasks in this step to complete
                    var allSucceeded = true
                    for await success in group {
                        if !success {
                            allSucceeded = false
                        }
                    }

                    // If any task failed, stop the chain
                    if !allSucceeded {
                        result(FlutterError(
                            code: "CHAIN_FAILED",
                            message: "Chain step \(stepIndex + 1) failed",
                            details: nil
                        ))
                        return
                    }
                }
            }

            print("NativeWorkManager: Chain '\(chainName ?? "unnamed")' completed successfully")
            result("ACCEPTED")
        }
    }

    /// Execute a worker synchronously and return success status.
    private func executeWorkerSync(
        taskId: String,
        workerClassName: String,
        workerConfig: [String: Any],
        qos: String = "background"
    ) async -> Bool {
        print("NativeWorkManager: Executing task '\(taskId)' in chain with QoS: \(qos)...")

        // Map QoS string to DispatchQoS
        let qosClass = mapQoS(qos)

        return await withCheckedContinuation { (continuation: CheckedContinuation<Bool, Never>) in
            DispatchQueue.global(qos: qosClass).async {
                Task {
                    // Convert worker config to JSON string
                    guard let jsonData = try? JSONSerialization.data(withJSONObject: workerConfig),
                          let inputJson = String(data: jsonData, encoding: .utf8) else {
                        print("NativeWorkManager: Error serializing worker config")
                        self.emitTaskEvent(taskId: taskId, success: false, message: "Config serialization failed")
                        continuation.resume(returning: false)
                        return
                    }

                    // Create worker
                    guard let worker = IosWorkerFactory.createWorker(className: workerClassName) else {
                        print("NativeWorkManager: Unknown worker class: \(workerClassName)")
                        self.emitTaskEvent(taskId: taskId, success: false, message: "Unknown worker class")
                        continuation.resume(returning: false)
                        return
                    }

                    // Execute worker
                    do {
                        let success = try await worker.doWork(input: inputJson)

                        if success {
                            print("NativeWorkManager: Task '\(taskId)' completed successfully")
                            self.emitTaskEvent(taskId: taskId, success: true, message: nil)
                        } else {
                            print("NativeWorkManager: Task '\(taskId)' failed")
                            self.emitTaskEvent(taskId: taskId, success: false, message: "Worker returned false")
                        }

                        continuation.resume(returning: success)
                    } catch {
                        print("NativeWorkManager: Task '\(taskId)' error: \(error.localizedDescription)")
                        self.emitTaskEvent(taskId: taskId, success: false, message: error.localizedDescription)
                        continuation.resume(returning: false)
                    }
                }
            }
        }
    }

    // MARK: - Event Emission

    func emitTaskEvent(taskId: String, success: Bool, message: String?) {
        eventSink?([
            "taskId": taskId,
            "success": success,
            "message": message as Any,
            "timestamp": Int(Date().timeIntervalSince1970 * 1000)
        ])
    }

    func emitProgress(taskId: String, progress: Int, message: String?) {
        progressSink?([
            "taskId": taskId,
            "progress": progress,
            "message": message as Any
        ])
    }
}

// MARK: - FlutterStreamHandler

extension NativeWorkmanagerPlugin: FlutterStreamHandler {
    public func onListen(withArguments arguments: Any?, eventSink events: @escaping FlutterEventSink) -> FlutterError? {
        self.eventSink = events

        // TODO: Subscribe to KMP TaskEventBus
        // Task {
        //     for await event in TaskEventBus.shared.events {
        //         events([...])
        //     }
        // }

        return nil
    }

    public func onCancel(withArguments arguments: Any?) -> FlutterError? {
        eventSink = nil
        return nil
    }
}

// MARK: - Progress Stream Handler

private class ProgressStreamHandler: NSObject, FlutterStreamHandler {
    weak var plugin: NativeWorkmanagerPlugin?

    init(plugin: NativeWorkmanagerPlugin) {
        self.plugin = plugin
    }

    func onListen(withArguments arguments: Any?, eventSink events: @escaping FlutterEventSink) -> FlutterError? {
        // TODO: Subscribe to progress updates
        return nil
    }

    func onCancel(withArguments arguments: Any?) -> FlutterError? {
        return nil
    }
}
