import Flutter
import UIKit
// KMPWorkManager will be available after pod install
// import KMPWorkManager

/// Native WorkManager Flutter Plugin for iOS.
///
/// This plugin provides native background task scheduling using iOS workers
/// (Mode 1: Native HTTP workers) and Dart workers (Mode 2: FlutterEngine-based).
///
/// **Architecture:**
/// - Mode 1: Native workers (HttpRequest, Upload, Download, Sync) - Zero Flutter overhead
/// - Mode 2: Dart workers (DartCallbackWorker) - Full Flutter plugin access
///
/// **Workers are executed via iOS URLSession and FlutterEngine respectively.**
public class NativeWorkmanagerPlugin: NSObject, FlutterPlugin {

    private var methodChannel: FlutterMethodChannel?
    private var eventChannel: FlutterEventChannel?
    private var progressChannel: FlutterEventChannel?

    private var eventSink: FlutterEventSink?
    private var progressSink: FlutterEventSink?

    private static let methodChannelName = "dev.brewkits/native_workmanager"
    private static let eventChannelName = "dev.brewkits/native_workmanager/events"
    private static let progressChannelName = "dev.brewkits/native_workmanager/progress"

    // Background task execution queue
    private let workerQueue = DispatchQueue(label: "dev.brewkits.native_workmanager.worker",
                                           qos: .utility)

    public static func register(with registrar: FlutterPluginRegistrar) {
        let instance = NativeWorkmanagerPlugin()

        // Setup Method Channel
        let methodChannel = FlutterMethodChannel(
            name: methodChannelName,
            binaryMessenger: registrar.messenger()
        )
        registrar.addMethodCallDelegate(instance, channel: methodChannel)
        instance.methodChannel = methodChannel

        // Setup Event Channel for task completion events
        let eventChannel = FlutterEventChannel(
            name: eventChannelName,
            binaryMessenger: registrar.messenger()
        )
        eventChannel.setStreamHandler(instance)
        instance.eventChannel = eventChannel

        // Setup Progress Channel for task progress updates
        let progressChannel = FlutterEventChannel(
            name: progressChannelName,
            binaryMessenger: registrar.messenger()
        )
        progressChannel.setStreamHandler(ProgressStreamHandler(plugin: instance))
        instance.progressChannel = progressChannel

        // Register BGTaskScheduler handlers (iOS 13+)
        if #available(iOS 13.0, *) {
            // Validate Info.plist configuration
            InfoPlistValidator.printSetupGuideIfNeeded()

            BGTaskSchedulerManager.shared.registerHandlers()
            BGTaskSchedulerManager.shared.onTaskComplete = { taskId, success, message in
                instance.emitTaskEvent(taskId: taskId, success: success, message: message)
            }
        }

        print("NativeWorkmanagerPlugin: Registered")
    }

    public func handle(_ call: FlutterMethodCall, result: @escaping FlutterResult) {
        switch call.method {
        case "initialize":
            handleInitialize(call: call, result: result)
        case "enqueue":
            handleEnqueue(call: call, result: result)
        case "cancel":
            handleCancel(call: call, result: result)
        case "cancelAll":
            handleCancelAll(result: result)
        case "getTaskStatus":
            handleGetTaskStatus(call: call, result: result)
        case "enqueueChain":
            handleEnqueueChain(call: call, result: result)
        default:
            result(FlutterMethodNotImplemented)
        }
    }

    // MARK: - Method Handlers

    private func handleInitialize(call: FlutterMethodCall, result: @escaping FlutterResult) {
        // Initialize KMP WorkManager
        KMPBridge.shared.initialize()

        // Extract callback handle if provided (for Dart workers)
        if let args = call.arguments as? [String: Any],
           let callbackHandle = args["callbackHandle"] as? Int64 {
            FlutterEngineManager.shared.setCallbackHandle(callbackHandle)
            print("NativeWorkManager: Initialized with Dart callback handle: \(callbackHandle)")
        } else {
            print("NativeWorkManager: Initialized (KMP native workers)")
        }

        result(nil)
    }

    private func handleEnqueue(call: FlutterMethodCall, result: @escaping FlutterResult) {
        guard let args = call.arguments as? [String: Any],
              let taskId = args["taskId"] as? String,
              let triggerMap = args["trigger"] as? [String: Any],
              let workerClassName = args["workerClassName"] as? String else {
            result(FlutterError(code: "INVALID_ARGS", message: "Missing required arguments", details: nil))
            return
        }

        print("NativeWorkManager: Enqueue task '\(taskId)' with worker '\(workerClassName)' via KMP scheduler")

        // Get KMP scheduler
        guard let scheduler = KMPBridge.shared.getScheduler() else {
            result(FlutterError(
                code: "NOT_INITIALIZED",
                message: "KMP WorkManager not initialized",
                details: nil
            ))
            return
        }

        // Extract parameters
        let constraintsMap = args["constraints"] as? [String: Any]
        let workerConfig = args["workerConfig"] as? [String: Any]
        let policyString = args["existingPolicy"] as? String

        // Convert workerConfig to JSON string for KMP
        var inputJson: String? = nil
        if let config = workerConfig,
           let jsonData = try? JSONSerialization.data(withJSONObject: config),
           let jsonString = String(data: jsonData, encoding: .utf8) {
            inputJson = jsonString
        }

        // Call KMP scheduler
        KMPSchedulerBridge.enqueue(
            scheduler: scheduler,
            taskId: taskId,
            triggerMap: triggerMap,
            workerClassName: workerClassName,
            constraintsMap: constraintsMap,
            inputJson: inputJson,
            policyString: policyString
        ) { scheduleResult in
            switch scheduleResult {
            case .success(let schedResult):
                let resultString = KMPSchedulerBridge.scheduleResultToString(schedResult)
                print("✅ KMP Scheduler: Task '\(taskId)' enqueued with result: \(resultString)")
                result(resultString)
            case .failure(let error):
                print("❌ KMP Scheduler: Failed to enqueue task '\(taskId)' - \(error)")
                result(FlutterError(
                    code: "ENQUEUE_FAILED",
                    message: error.localizedDescription,
                    details: nil
                ))
            }
        }
    }

    // MARK: - Legacy Implementation (Removed in Phase 2)
    // The old direct Swift worker execution has been replaced with KMP scheduler calls
    // All background tasks are now scheduled through kmpworkmanager v2.1.2


    private func handleCancel(call: FlutterMethodCall, result: @escaping FlutterResult) {
        guard let args = call.arguments as? [String: Any],
              let taskId = args["taskId"] as? String else {
            result(FlutterError(code: "INVALID_ARGS", message: "taskId is required", details: nil))
            return
        }

        print("NativeWorkManager: Cancel task \(taskId) via KMP scheduler")

        // Get KMP scheduler
        guard let scheduler = KMPBridge.shared.getScheduler() else {
            // Fallback to legacy BGTaskScheduler if KMP not ready
            if #available(iOS 13.0, *) {
                BGTaskSchedulerManager.shared.cancelTask(taskId: taskId)
            }
            result(nil)
            return
        }

        // Cancel via KMP scheduler
        scheduler.cancel(id: taskId)
        print("✅ KMP Scheduler: Task '\(taskId)' cancelled")
        result(nil)
    }

    private func handleCancelAll(result: @escaping FlutterResult) {
        print("NativeWorkManager: Cancel all tasks via KMP scheduler")

        // Get KMP scheduler
        guard let scheduler = KMPBridge.shared.getScheduler() else {
            // Fallback to legacy BGTaskScheduler if KMP not ready
            if #available(iOS 13.0, *) {
                BGTaskSchedulerManager.shared.cancelAllTasks()
            }
            result(nil)
            return
        }

        // Cancel all via KMP scheduler
        scheduler.cancelAll()
        print("✅ KMP Scheduler: All tasks cancelled")
        result(nil)
    }

    private func handleGetTaskStatus(call: FlutterMethodCall, result: @escaping FlutterResult) {
        // TODO: Implement task status query
        result(nil)
    }

    private func handleEnqueueChain(call: FlutterMethodCall, result: @escaping FlutterResult) {
        guard let args = call.arguments as? [String: Any],
              let stepsData = args["steps"] as? [[Any]] else {
            result(FlutterError(code: "INVALID_ARGS", message: "steps is required", details: nil))
            return
        }

        let chainName = args["name"] as? String
        let constraintsMap = args["constraints"] as? [String: Any]
        let qos = constraintsMap?["qos"] as? String ?? "background"

        print("NativeWorkManager: Enqueue chain '\(chainName ?? "unnamed")' with \(stepsData.count) steps")

        // Execute chain steps sequentially
        workerQueue.async { [weak self] in
            self?.executeChain(
                steps: stepsData,
                chainName: chainName,
                constraintsMap: constraintsMap,
                qos: qos,
                result: result
            )
        }
    }

    /// Execute a task chain sequentially.
    private func executeChain(
        steps: [[Any]],
        chainName: String?,
        constraintsMap: [String: Any]?,
        qos: String,
        result: @escaping FlutterResult
    ) {
        Task {
            for (stepIndex, stepData) in steps.enumerated() {
                print("NativeWorkManager: Chain '\(chainName ?? "unnamed")' - Step \(stepIndex + 1)/\(steps.count)")

                // Parse tasks in this step
                guard let stepTasks = stepData as? [[String: Any]] else {
                    result(FlutterError(
                        code: "INVALID_STEP",
                        message: "Step \(stepIndex) has invalid format",
                        details: nil
                    ))
                    return
                }

                // Execute tasks in parallel (if multiple tasks in step)
                await withTaskGroup(of: Bool.self) { group in
                    for taskData in stepTasks {
                        guard let taskId = taskData["id"] as? String,
                              let workerClassName = taskData["workerClassName"] as? String,
                              let workerConfig = taskData["workerConfig"] as? [String: Any] else {
                            continue
                        }

                        group.addTask {
                            await self.executeWorkerSync(
                                taskId: taskId,
                                workerClassName: workerClassName,
                                workerConfig: workerConfig,
                                qos: qos
                            )
                        }
                    }

                    // Wait for all tasks in this step to complete
                    var allSucceeded = true
                    for await success in group {
                        if !success {
                            allSucceeded = false
                        }
                    }

                    // If any task failed, stop the chain
                    if !allSucceeded {
                        result(FlutterError(
                            code: "CHAIN_FAILED",
                            message: "Chain step \(stepIndex + 1) failed",
                            details: nil
                        ))
                        return
                    }
                }
            }

            print("NativeWorkManager: Chain '\(chainName ?? "unnamed")' completed successfully")
            result("ACCEPTED")
        }
    }

    /// Execute a worker synchronously and return success status.
    private func executeWorkerSync(
        taskId: String,
        workerClassName: String,
        workerConfig: [String: Any],
        qos: String = "background"
    ) async -> Bool {
        print("NativeWorkManager: Executing task '\(taskId)' in chain with QoS: \(qos)...")

        // Map QoS string to DispatchQoS
        let qosClass = mapQoS(qos)

        return await withCheckedContinuation { (continuation: CheckedContinuation<Bool, Never>) in
            DispatchQueue.global(qos: qosClass).async {
                Task {
                    // Convert worker config to JSON string
                    guard let jsonData = try? JSONSerialization.data(withJSONObject: workerConfig),
                          let inputJson = String(data: jsonData, encoding: .utf8) else {
                        print("NativeWorkManager: Error serializing worker config")
                        self.emitTaskEvent(taskId: taskId, success: false, message: "Config serialization failed")
                        continuation.resume(returning: false)
                        return
                    }

                    // Create worker
                    guard let worker = IosWorkerFactory.createWorker(className: workerClassName) else {
                        print("NativeWorkManager: Unknown worker class: \(workerClassName)")
                        self.emitTaskEvent(taskId: taskId, success: false, message: "Unknown worker class")
                        continuation.resume(returning: false)
                        return
                    }

                    // Execute worker
                    do {
                        let success = try await worker.doWork(input: inputJson)

                        if success {
                            print("NativeWorkManager: Task '\(taskId)' completed successfully")
                            self.emitTaskEvent(taskId: taskId, success: true, message: nil)
                        } else {
                            print("NativeWorkManager: Task '\(taskId)' failed")
                            self.emitTaskEvent(taskId: taskId, success: false, message: "Worker returned false")
                        }

                        continuation.resume(returning: success)
                    } catch {
                        print("NativeWorkManager: Task '\(taskId)' error: \(error.localizedDescription)")
                        self.emitTaskEvent(taskId: taskId, success: false, message: error.localizedDescription)
                        continuation.resume(returning: false)
                    }
                }
            }
        }
    }

    // MARK: - Event Emission

    func emitTaskEvent(taskId: String, success: Bool, message: String?) {
        eventSink?([
            "taskId": taskId,
            "success": success,
            "message": message as Any,
            "timestamp": Int(Date().timeIntervalSince1970 * 1000)
        ])
    }

    func emitProgress(taskId: String, progress: Int, message: String?) {
        progressSink?([
            "taskId": taskId,
            "progress": progress,
            "message": message as Any
        ])
    }
}

// MARK: - FlutterStreamHandler

extension NativeWorkmanagerPlugin: FlutterStreamHandler {
    public func onListen(withArguments arguments: Any?, eventSink events: @escaping FlutterEventSink) -> FlutterError? {
        self.eventSink = events

        // TODO: Subscribe to KMP TaskEventBus
        // Task {
        //     for await event in TaskEventBus.shared.events {
        //         events([...])
        //     }
        // }

        return nil
    }

    public func onCancel(withArguments arguments: Any?) -> FlutterError? {
        eventSink = nil
        return nil
    }
}

// MARK: - Progress Stream Handler

private class ProgressStreamHandler: NSObject, FlutterStreamHandler {
    weak var plugin: NativeWorkmanagerPlugin?

    init(plugin: NativeWorkmanagerPlugin) {
        self.plugin = plugin
    }

    func onListen(withArguments arguments: Any?, eventSink events: @escaping FlutterEventSink) -> FlutterError? {
        // TODO: Subscribe to progress updates
        return nil
    }

    func onCancel(withArguments arguments: Any?) -> FlutterError? {
        return nil
    }
}
